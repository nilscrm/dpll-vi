
use std::data::Map;
use std::ops::comparison::Eq;
use std::debug::Show;

pub struct* Literal(I32);
pub struct* Clause(List[Literal]);
pub struct* Formula(List[Clause]);

pub mod cnf;

pub fn main(&io: &IO) {
  let formula = Formula([
    Clause([Literal(+1), Literal(-2)]),
    Clause([Literal(-2)]),
    Clause([Literal(-1), Literal(+2)]),
  ]);

  match formula.solve() {
    Some(solution) {
      io.println("satisfiable");
      for (var, value) in solution!.into_iter() {
        io.println("x{var} = {value}");
      }
    }
    None {
      io.println("unsatisfiable");
    }
  }
}

pub mod Formula {
  pub fn .solve(&self: &Formula) -> Option[Model] {
    self.dpll(Model::empty)
  }

  pub fn .evaluate(&self: &Formula, &assignment: &Model) -> Bool {
    self!.iter().all(fn* (&clause: &Clause) { clause.evaluate(&assignment) })
  }

  pub fn .dpll(formula: Formula, assignment: Model) -> Option[Model] {
    loop {
      if formula.is_empty() {
        return Some(assignment);
      }

      if formula!.iter().any(Clause::is_empty) {
        return None;
      }

      if formula.find_unit() is Some(literal) {
        assignment.insert(literal.variable(), literal.is_positive());
        if formula.assign(literal) is Some(new_formula) {
          formula = new_formula;
          continue;
        } else {
          return None;
        }
      }

      if formula.find_pure() is Some(literal) {
        assignment.insert(literal.variable(), literal.is_positive());
        if formula.assign(literal) is Some(new_formula) {
          formula = new_formula;
          continue;
        } else {
          return None;
        }
      }

      break;
    }

    let Some(branch_literal) = formula.choose_literal() else {
      return Some(assignment);
    };

    if formula.assign(branch_literal) is Some(next_formula) {
      let new_assignment = assignment.fork();
      new_assignment.insert(branch_literal.variable(), branch_literal.is_positive());
      if next_formula.dpll(new_assignment) is Some(solution) {
        return Some(solution);
      }
    }

    if formula.assign(branch_literal.negated()) is Some(next_formula) {
      assignment.insert(branch_literal.variable(), !branch_literal.is_positive());
      if next_formula.dpll(assignment) is Some(solution) {
        return Some(solution);
      }
    }

    None
  }

  fn .is_empty(&self: &Formula) -> Bool {
    self!.len() == 0
  }

  fn .find_unit(&self: &Formula) -> Option[Literal] {
    self!.find(fn* (&clause: &Clause) { clause.is_unit() }).map(fn? (&clause: &Clause) {
      clause!.get(0).unwrap()
    })
  }

  // TODO: should just return a list of pure literals
  fn .find_pure(&self: &Formula) -> Option[Literal] {
    let occurrences = Map::empty[N32, (Bool, Bool)];
    for &clause in self!.iter() {
      for &literal in clause!.iter() {
        let &(pos, neg) = occurrences.at_or_insert(literal.variable(), (false, false));
        if literal.is_positive() {
          pos = true;
        } else {
          neg = true;
        }
      }
    }

    let iter = occurrences.into_iter();
    for (var, (pos, neg)) in iter {
      if pos && !neg {
        return Some(Literal::pos(var));
      }
      if neg && !pos {
        return Some(Literal::neg(var));
      }
    }
    None
  }

  fn .choose_literal(&self: &Formula) -> Option[Literal] {
    for &clause in self!.iter() {
      for &literal in clause!.iter() {
        return Some(literal);
      }
    }
    None
  }

  fn .assign(self: Formula, literal: Literal) -> Option[Formula] {
    let new_clauses = [];
    for clause in self!.into_iter() {
      if clause!.contains(&literal) {
        continue;
      }

      let new_clause = clause!.filter(fn* (&lit) { lit != literal.negated() });

      if new_clause.len() == 0 {
        return None;
      }
      new_clauses.push_back(Clause(new_clause));
    }
    Some(Formula(new_clauses))
  }

  pub impl show: Show[Formula];
}

pub struct* Model(pub Map[N32, Bool]);

pub mod Model {
  pub const empty: Model = Model(Map::empty);

  pub fn .insert(&self: &Model, variable: N32, value: Bool) {
    self!.insert(variable, value);
  }

  pub impl show: Show[Model];
}

pub mod Clause {
  pub fn .evaluate(&self: &Clause, &assignment: &Model) -> Bool {
    self!.iter().any(fn* (&literal: &Literal) { literal.evaluate(&assignment) })
  }

  pub fn .is_empty(&self: &Clause) -> Bool {
    self!.len() == 0
  }

  pub fn .is_unit(&self: &Clause) -> Bool {
    self!.len() == 1
  }

  pub fn .first_literal(&self: &Clause) -> Option[Literal] {
    self!.get(0)
  }

  pub impl show: Show[Clause];
}

pub mod Literal {
  pub fn pos(var: N32) -> Literal {
    Literal(var as I32)
  }

  pub fn neg(var: N32) -> Literal {
    Literal(-var as I32)
  }

  pub fn .evaluate(&self: &Literal, &assignment: &Model) -> Bool {
    let var = self.variable();
    let Some(value) = assignment!.get(&var) else {
      return false;
    };
    if self.is_positive() {
      value
    } else {
      !value
    }
  }

  pub fn .variable(&Literal(int)) -> N32 {
    int.abs() as N32
  }

  pub fn .is_positive(&Literal(int)) -> Bool {
    int > +0
  }

  pub fn .negated(&Literal(int)) -> Literal {
    Literal(-int)
  }

  pub impl show: Show[Literal] {
    fn show(&self: &Literal) -> Show {
      if self.is_positive() {
        Show::Literal("x{self.variable()}")
      } else {
        Show::Literal("Â¬x{self.variable()}")
      }
    }
  }

  pub impl eq: Eq[Literal] {
    fn eq(&Literal(self), &Literal(other)) -> Bool {
      self == other
    }

    fn ne(&Literal(self), &Literal(other)) -> Bool {
      self != other
    }
  }
}
